# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c9zFkzPXbmrq1THt64_FVP-7QLrcMuGy
"""

# 1. –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞—Ç–∞—Å–µ—Ç digits
from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.metrics import classification_report, accuracy_score
import matplotlib.pyplot as plt
import numpy as np

print("=== –ó–ê–ì–†–£–ó–ö–ê –î–ê–¢–ê–°–ï–¢–ê DIGITS ===")
digits = load_digits()
X = digits.data  # –¥–∞–Ω–Ω—ã–µ (1797 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π, –∫–∞–∂–¥–æ–µ 8x8 = 64 –ø–∏–∫—Å–µ–ª—è)
y = digits.target  # –º–µ—Ç–∫–∏ (—Ü–∏—Ñ—Ä—ã –æ—Ç 0 –¥–æ 9)

print(f"–†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö: {X.shape}")
print(f"–†–∞–∑–º–µ—Ä –º–µ—Ç–æ–∫: {y.shape}")
print(f"–ö–ª–∞—Å—Å—ã: {np.unique(y)}")

# –ü–æ–∫–∞–∂–µ–º –ø—Ä–∏–º–µ—Ä —Ü–∏—Ñ—Ä—ã
plt.figure(figsize=(8, 4))
for i in range(10):
    plt.subplot(2, 5, i + 1)
    plt.imshow(digits.images[i], cmap='binary')
    plt.title(f"–¶–∏—Ñ—Ä–∞: {digits.target[i]}")
    plt.axis('off')
plt.tight_layout()
plt.show()

# 2. –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –æ–±—É—á–∞—é—â—É—é –∏ —Ç–µ—Å—Ç–æ–≤—É—é –≤—ã–±–æ—Ä–∫–∏
print("\n=== –†–ê–ó–î–ï–õ–ï–ù–ò–ï –î–ê–ù–ù–´–• ===")
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)
print(f"–û–±—É—á–∞—é—â–∞—è –≤—ã–±–æ—Ä–∫–∞: {X_train.shape[0]} –ø—Ä–∏–º–µ—Ä–æ–≤")
print(f"–¢–µ—Å—Ç–æ–≤–∞—è –≤—ã–±–æ—Ä–∫–∞: {X_test.shape[0]} –ø—Ä–∏–º–µ—Ä–æ–≤")

# 3. –û–±—É—á–∞–µ–º —Ç—Ä–∏ –º–æ–¥–µ–ª–∏
print("\n=== –û–ë–£–ß–ï–ù–ò–ï –ú–û–î–ï–õ–ï–ô ===")

models = {
    'k-NN': KNeighborsClassifier(n_neighbors=3),
    'Decision Tree': DecisionTreeClassifier(random_state=42, max_depth=10),
    'SVM': SVC(random_state=42, kernel='rbf')
}

# –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
results = {}

# 4. –û–±—É—á–µ–Ω–∏–µ –∏ –æ—Ü–µ–Ω–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏
for name, model in models.items():
    print(f"\n{'='*60}")
    print(f"–ú–û–î–ï–õ–¨: {name}")
    print(f"{'='*60}")

    # –û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏
    model.fit(X_train, y_train)

    # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–µ
    y_pred = model.predict(X_test)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    results[name] = {
        'model': model,
        'predictions': y_pred,
        'accuracy': accuracy_score(y_test, y_pred)
    }

    # Classification report –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–¥–µ–ª–∏
    print(f"–û–¢–ß–ï–¢ –ü–û –ö–õ–ê–°–°–ò–§–ò–ö–ê–¶–ò–ò –î–õ–Ø {name}:")
    print(classification_report(y_test, y_pred, digits=4))
    print(f"–û–ë–©–ê–Ø –¢–û–ß–ù–û–°–¢–¨: {results[name]['accuracy']:.4f}")

# 5. –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π
print(f"\n{'='*70}")
print("–°–†–ê–í–ù–ï–ù–ò–ï –ú–û–î–ï–õ–ï–ô")
print(f"{'='*70}")

# –°–æ—Ä—Ç–∏—Ä—É–µ–º –º–æ–¥–µ–ª–∏ –ø–æ —Ç–æ—á–Ω–æ—Å—Ç–∏
sorted_results = sorted(results.items(), key=lambda x: x[1]['accuracy'], reverse=True)

print("–†–ï–ô–¢–ò–ù–ì –ú–û–î–ï–õ–ï–ô –ü–û –¢–û–ß–ù–û–°–¢–ò:")
for i, (name, result) in enumerate(sorted_results, 1):
    print(f"{i}. {name}: {result['accuracy']:.4f}")

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ª—É—á—à—É—é –º–æ–¥–µ–ª—å
best_model_name, best_result = sorted_results[0]
print(f"\nüéØ –õ–£–ß–®–ê–Ø –ú–û–î–ï–õ–¨: {best_model_name} —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é {best_result['accuracy']:.4f}")

# –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã –ª—É—á—à–µ–π –º–æ–¥–µ–ª–∏ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–∏–º–µ—Ä–∞—Ö
print(f"\n=== –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ê–ë–û–¢–´ –õ–£–ß–®–ï–ô –ú–û–î–ï–õ–ò ({best_model_name}) ===")

best_model = best_result['model']

# –ë–µ—Ä–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ª—É—á–∞–π–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–æ–≤ –∏–∑ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–∏
np.random.seed(42)
sample_indices = np.random.choice(len(X_test), 5, replace=False)

plt.figure(figsize=(12, 3))
for i, idx in enumerate(sample_indices):
    # –ë–µ—Ä–µ–º –ø—Ä–∏–º–µ—Ä –∏–∑ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–∏
    test_image = X_test[idx].reshape(8, 8)
    true_label = y_test[idx]

    # –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ü–∏—Ñ—Ä—É
    predicted_label = best_model.predict([X_test[idx]])[0]

    # –í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ–º
    plt.subplot(1, 5, i + 1)
    plt.imshow(test_image, cmap='binary')
    plt.title(f"–ò—Å—Ç–∏–Ω–∞: {true_label}\n–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–æ: {predicted_label}",
              color='green' if true_label == predicted_label else 'red')
    plt.axis('off')

plt.tight_layout()
plt.show()

# –ê–Ω–∞–ª–∏–∑ –æ—à–∏–±–æ–∫
print("\n=== –ê–ù–ê–õ–ò–ó –û–®–ò–ë–û–ö ===")
wrong_predictions = []
for i in range(len(X_test)):
    if y_test[i] != results[best_model_name]['predictions'][i]:
        wrong_predictions.append({
            'index': i,
            'true': y_test[i],
            'predicted': results[best_model_name]['predictions'][i]
        })

print(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫ —É –ª—É—á—à–µ–π –º–æ–¥–µ–ª–∏: {len(wrong_predictions)}")
print(f"–¢–æ—á–Ω–æ—Å—Ç—å: {(1 - len(wrong_predictions)/len(X_test)):.4f}")

if wrong_predictions:
    print("\n–ü—Ä–∏–º–µ—Ä—ã –æ—à–∏–±–æ–∫:")
    for i, error in enumerate(wrong_predictions[:3]):
        print(f"  –ü—Ä–∏–º–µ—Ä {error['index']}: –∏—Å—Ç–∏–Ω–Ω–∞—è —Ü–∏—Ñ—Ä–∞ {error['true']}, –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∞ {error['predicted']}")